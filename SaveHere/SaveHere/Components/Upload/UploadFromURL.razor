@page "/uploadfromurl"

@implements IAsyncDisposable

@using Microsoft.EntityFrameworkCore
@using SaveHere.Models
@using SaveHere.Models.db
@using SaveHere.Services
@using SaveHere.Helpers
@using System.Net
@using System.Diagnostics
@using Microsoft.AspNetCore.SignalR.Client

@inject NavigationManager NavigationManager

@rendermode InteractiveServer
@attribute [StreamRendering]

<MudPopoverProvider />
<MudDialogProvider />
<MudSnackbarProvider />

<PageTitle>Upload From URL</PageTitle>

<MudStack>

  <MudPaper Class="px-5 pt-4 mx-5 mt-5" Elevation="5">

    <MudStack Row>

      <MudTextField @bind-Value="UrlText" Label="File URL" Variant="Variant.Outlined" Margin="Margin.Dense"
                    HelperText="Enter The File URL To Upload To The Server" HelperTextOnFocus="true" Adornment="Adornment.End"
                    AdornmentIcon="@Icons.Material.Filled.InsertLink" AdornmentColor="Color.Info" Clearable="true"
                    Immediate="true" />

      <MudButton Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Add" Color="Color.Primary"
                 Style="text-transform:none; height:40px; margin-top:0.5rem;" Class="pr-5" Size="Size.Small" OnClick="AddURL">Add</MudButton>

    </MudStack>

  </MudPaper>

  @if (!string.IsNullOrWhiteSpace(ErrorMessage))
  {
    <MudAlert Severity="Severity.Error" Variant="Variant.Outlined" Dense="true" Elevation="10" ContentAlignment="HorizontalAlignment.Center" Class="mx-5" ShowCloseIcon="true" CloseIconClicked="ClearErrorMessage">
      @ErrorMessage
    </MudAlert>
  }

  <MudTable Items="@_fileDownloadQueueItems" Dense="true" Hover="true" Loading="@_isLoadingTheList" Class="pa-5 mx-5" Elevation="5">
    <ColGroup>
      <col style="width: 60%" />
      <col style="width: 10%" />
      <col style="width: 10%" />
      <col style="width: 20%" />
    </ColGroup>
    <HeaderContent>
      <MudTh>URL</MudTh>
      <MudTh>Status</MudTh>
      <MudTh>Progress</MudTh>
      <MudTh>Actions</MudTh>
    </HeaderContent>
    <RowTemplate>
      <MudTd DataLabel="URL" Style="word-break:break-all;">
        @context.InputUrl
      </MudTd>
      <MudTd DataLabel="Status">@context.Status</MudTd>
      <MudTd DataLabel="Progress">
        <MudStack Spacing="0">

          <MudText Typo="Typo.body2" Align="Align.Left" Class="ma-0 pa-0">
            spd @FormatSpeed(context.CurrentDownloadSpeed)
          </MudText>

          <MudStack Row="true" Spacing="1" Justify="Justify.SpaceBetween">
            <MudProgressLinear Value="@context.ProgressPercentage" Color="Color.Tertiary" Striped="true" Class="ma-0 pa-0" Size="Size.Large" />

            <MudText Typo="Typo.inherit" Color="Color.Warning" Class="ma-0 pa-0" Align="Align.Right" Inline="true" Style="font-size:10px;">
              @context.ProgressPercentage%
            </MudText>
          </MudStack>

          <MudText Typo="Typo.body2" Align="Align.Left" Class="ma-0 pa-0">
            avg @FormatSpeed(context.AverageDownloadSpeed)
          </MudText>

        </MudStack>
      </MudTd>
      <MudTd DataLabel="Actions">
        <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small" OnClick="async() =>
            {
            if (context.Status==EQueueItemStatus.Downloading) await PauseDownload(context); else await StartDownload(context);
            }">
          @(context.Status == EQueueItemStatus.Downloading ? "Pause" : "Start")
        </MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Secondary" Size="Size.Small" OnClick="async() => await DeleteItem(context)">Delete</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Error" Size="Size.Small" OnClick="() => CancelDownload(context)">Cancel</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Info" Size="Size.Small" OnClick="() => ToggleMoreOptions(context)">@(context.bShowMoreOptions ? "Close" : "More")</MudButton>
      </MudTd>
    </RowTemplate>
    <ChildRowContent>
      @if (context.bShowMoreOptions)
      {
        <MudTr>
          <MudTd ColSpan="4">
            <MudPaper Class="pa-5" Elevation="0" Outlined="true">
              <MudStack>
                <MudCheckBox @bind-Value="@context.bShouldGetFilenameFromHttpHeaders" Label="Use Headers For Filename" Color="Color.Primary" />
              </MudStack>
            </MudPaper>
          </MudTd>
        </MudTr>
      }
    </ChildRowContent>
  </MudTable>

</MudStack>

@code {
  [Inject] public required AppDbContext _context { get; set; }
  [Inject] private PersistentComponentState _persistentState { get; set; } = default!;
  [Inject] public required DownloadStateService DownloadState { get; set; }
  [Inject] private HttpClient _httpClient { get; set; } = default!;
  [Inject] public IDownloadQueueService DownloadQueueService { get; set; } = default!;

  private HubConnection? hubConnection;

  private string UrlText { get; set; } = "";
  private string ErrorMessage { get; set; } = "";

  private List<FileDownloadQueueItem> _fileDownloadQueueItems = new();
  private bool _isLoadingTheList = false;

  protected override async Task OnInitializedAsync()
  {
    _persistentState.RegisterOnPersisting(PersistItems);

    if (_persistentState.TryTakeFromJson<List<FileDownloadQueueItem>>(nameof(_fileDownloadQueueItems), out var savedItems) && savedItems != null)
    {
      _fileDownloadQueueItems = savedItems;
    }
    else
    {
      await LoadDownloadItemsList();
    }

    // Set up signalR connection
    hubConnection = new HubConnectionBuilder()
      .WithUrl(NavigationManager.ToAbsoluteUri("/DownloadProgressHub"))
      .WithAutomaticReconnect()
      .Build();

    hubConnection.Closed += async (error) =>
    {
      if (error != null)
      {
        ErrorMessage = $"SignalR Connection Closed: {error.Message}";
      }
      await Task.Delay(new Random().Next(0, 3) * 1000);
      await hubConnection.StartAsync();
    };

    hubConnection.On<DownloadProgress>("DownloadProgressUpdate", (update) =>
    {
      var item = _fileDownloadQueueItems.FirstOrDefault(x => x.Id == update.ItemId);
      if (item != null)
      {
        item.ProgressPercentage = update.ProgressPercentage;
        item.CurrentDownloadSpeed = update.CurrentSpeed;
        item.AverageDownloadSpeed = update.AverageSpeed;
        InvokeAsync(StateHasChanged);
      }
    });

    await hubConnection.StartAsync();
  }

  public async ValueTask DisposeAsync()
  {
    if (hubConnection is not null)
    {
      await hubConnection.DisposeAsync();
    }
  }

  private Task PersistItems()
  {
    _persistentState.PersistAsJson(nameof(_fileDownloadQueueItems), _fileDownloadQueueItems);
    return Task.CompletedTask;
  }

  private async Task LoadDownloadItemsList()
  {
    try
    {
      _isLoadingTheList = true;
      _fileDownloadQueueItems = await DownloadQueueService.GetQueueItemsAsync();
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Getting Items List: {exception.Message}";
    }
    finally
    {
      _isLoadingTheList = false;
    }
  }

  public async Task AddURL()
  {
    if (!string.IsNullOrWhiteSpace(UrlText))
    {
      try
      {
        var newFileDownload = new FileDownloadQueueItem() { InputUrl = UrlText };
        _context.FileDownloadQueueItems.Add(newFileDownload);
        await _context.SaveChangesAsync();

        ClearErrorMessage();

        await LoadDownloadItemsList();
      }
      catch (Exception exception)
      {
        ErrorMessage = $"An Error Occurred While Adding The URL: {exception.Message}";
      }
    }
    else
    {
      ErrorMessage = "Please Enter A Valid URL";
    }

    UrlText = "";
  }

  private void ClearErrorMessage()
  {
    ErrorMessage = "";
  }

  private async Task StartDownload(FileDownloadQueueItem item)
  {
    try
    {
      var progress = new Progress<DownloadProgress>(async update =>
      {
        item.ProgressPercentage = update.ProgressPercentage;
        item.CurrentDownloadSpeed = update.CurrentSpeed;
        item.AverageDownloadSpeed = update.AverageSpeed;

        if (hubConnection is not null)
        {
          await hubConnection.SendAsync("DownloadProgressUpdate", update);
        }

        await InvokeAsync(StateHasChanged);
      });

      await DownloadQueueService.StartDownloadAsync(item.Id, progress);
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Trying To Download: {exception.Message}";
    }
  }

  private async Task PauseDownload(FileDownloadQueueItem item)
  {
    // Implement pause functionality
    ErrorMessage = "Not Implemented Yet!";
  }

  private async Task CancelDownload(FileDownloadQueueItem item)
  {
    if (DownloadState.TryGetTokenSource(item.Id, out var tokenSource))
    {
      tokenSource?.Cancel();
      DownloadState.RemoveTokenSource(item.Id);
    }

    item.Status = EQueueItemStatus.Cancelled;
    await _context.SaveChangesAsync();
    await LoadDownloadItemsList();
  }

  private async Task DeleteItem(FileDownloadQueueItem item)
  {
    try
    {
      _context.FileDownloadQueueItems.Remove(item);
      DownloadState.RemoveTokenSource(item.Id);
      await _context.SaveChangesAsync();
      await LoadDownloadItemsList();
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Deleting The Item: {exception.Message}";
    }
  }

  private void ToggleMoreOptions(FileDownloadQueueItem item)
  {
    item.bShowMoreOptions = !item.bShowMoreOptions;
  }

  private string FormatSpeed(double speed)
  {
    if (speed == 0) return "0";
    else if (speed < 1024) return $"{speed:F2} B/s";
    else if (speed < 1024 * 1024) return $"{speed / 1024:F2} KB/s";
    else if (speed < 1024 * 1024 * 1024) return $"{speed / 1024 / 1024:F2} MB/s";
    else return $"{speed / 1024 / 1024 / 1024:F2} GB/s";
  }

}
