@page "/uploadfromurl"

@implements IAsyncDisposable

@using Microsoft.EntityFrameworkCore
@using SaveHere.Models
@using SaveHere.Models.db
@using SaveHere.Services
@using SaveHere.Helpers
@using System.Net
@using System.Diagnostics
@using Microsoft.AspNetCore.SignalR.Client

@rendermode InteractiveServer
@attribute [StreamRendering]

<MudPopoverProvider />
<MudDialogProvider />
<MudSnackbarProvider />

<PageTitle>Upload From URL</PageTitle>

  @if (!_isFullyLoaded)
{
  <div style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%;">
    <div style="position: relative;">
      <MudProgressCircular Color="Color.Success" Indeterminate="true" Class="ma-5" Style="width: 100px; height: 100px;" />
      <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -66%); text-align: center;">
        <div style="font-size: 12px;">Loading</div>
        <div style="font-size: 12px">Please Wait</div>
      </div>
    </div>
  </div>
}
else
{
  <MudStack Class="sv-main-stack">

    <MudPaper Class="px-5 pt-4 mx-5 mt-5 sv-paper" Elevation="5">

      <MudStack Row>

        <MudTextField @bind-Value="UrlText" Label="File URL" Variant="Variant.Outlined" Margin="Margin.Dense"
                      HelperText="Enter The File URL To Upload To The Server" HelperTextOnFocus="true" Adornment="Adornment.End"
                      AdornmentIcon="@Icons.Material.Filled.InsertLink" AdornmentColor="Color.Info" Clearable="true"
                      Immediate="true" />

        <MudButton Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Add" Color="Color.Primary"
                   Style="text-transform:none; height:40px; margin-top:0.5rem;" Class="pr-5" Size="Size.Small" OnClick="AddURL">Add</MudButton>

      </MudStack>

    </MudPaper>

    @if (!string.IsNullOrWhiteSpace(ErrorMessage))
    {
      <MudAlert Severity="Severity.Error" Variant="Variant.Outlined" Dense="true" Elevation="10" ContentAlignment="HorizontalAlignment.Center" Class="mx-5" ShowCloseIcon="true" CloseIconClicked="ClearErrorMessage">
        @ErrorMessage
      </MudAlert>
    }

    <MudTable Items="@_fileDownloadQueueItems" Dense="true" Hover="true" Loading="@_isLoadingTheList" Class="pa-5 mx-5 sv-table" Elevation="5">
      <HeaderContent>
        <MudTh Style="width:100%;">URL</MudTh>
        <MudTh Style="text-align:center; min-width:100px">Status</MudTh>
        <MudTh Style="text-align:center; min-width:200px">Progress</MudTh>
        <MudTh Style="text-align:center;">Actions</MudTh>
      </HeaderContent>
      <RowTemplate>
        <MudTd Style="word-break:break-all;" DataLabel="URL" Class="sv-table-custom-row-1">
          @context.InputUrl
        </MudTd>
        <MudTd Style="text-align:center;" Class="sv-table-custom-row-1" DataLabel="Status">@context.Status</MudTd>
        <MudTd Style="text-align:center" class="sv-table-custom-row-1" DataLabel="Progress">
          <MudStack Spacing="0" Class="sv-custom-progress-stack">

            <MudText Typo="Typo.body2" Align="Align.Left" Class="ma-0 pa-0">
              speed @FormatSpeed(context.CurrentDownloadSpeed)
            </MudText>

            <MudStack Row="true" Spacing="1" Justify="Justify.SpaceBetween">
              <MudProgressLinear Value="@context.ProgressPercentage" Color="Color.Tertiary" Striped="@(context.Status==EQueueItemStatus.Downloading)" Class="ma-0 pa-0 sv-progressbar" Style="width: 100%;" Size="Size.Large" />

              <MudText Typo="Typo.inherit" Color="Color.Warning" Class="ma-0 pa-0" Align="Align.Right" Inline="true" Style="font-size:10px;">
                @context.ProgressPercentage%
              </MudText>
            </MudStack>

            <MudText Typo="Typo.body2" Align="Align.Left" Class="ma-0 pa-0">
              average @FormatSpeed(context.AverageDownloadSpeed)
            </MudText>

          </MudStack>
        </MudTd>
        <MudTd Style="text-align:end;" Class="sv-table-custom-row-1" DataLabel="Actions">
          <MudStack Row="true" Style="gap:5px;">
            <MudButton Variant="Variant.Filled" Color="@(context.Status==EQueueItemStatus.Downloading?Color.Error:Color.Tertiary)" Size="Size.Small" OnClick="async() =>
            {
            if (context.Status==EQueueItemStatus.Downloading) await CancelDownload(context); else await StartDownload(context);
            }">
              @(context.Status == EQueueItemStatus.Downloading ? "Cancel" : "Start")
            </MudButton>
            <MudButton Variant="Variant.Filled" Color="Color.Secondary" Size="Size.Small" OnClick="async() => await DeleteItem(context)">Delete</MudButton>
            <MudButton Variant="Variant.Filled" Color="Color.Info" Size="Size.Small" OnClick="() => ToggleMoreOptions(context)">@(context.bShowMoreOptions ? "Close" : "More")</MudButton>
          </MudStack>
        </MudTd>
      </RowTemplate>
      <ChildRowContent>
        @if (context.bShowMoreOptions)
        {
          <MudTr Style="justify-content: start;">
            <MudTd ColSpan="4" Style="justify-content: start; width:100%;">
              <MudPaper Class="pa-5" Elevation="0" Outlined="true" Style="start; width:100%;">
                <MudStack>
                  <MudCheckBox @bind-Value="@context.bShouldGetFilenameFromHttpHeaders" Label="Use Headers For Filename" Color="Color.Primary" />
                </MudStack>
              </MudPaper>
            </MudTd>
          </MudTr>
        }
      </ChildRowContent>
    </MudTable>

    <MudTable Items="@_downloadDirectoryContents" Dense="true" Hover="true" Class="pa-5 mx-5 my-3 sv-table" Elevation="5">
      <HeaderContent>
        <MudTh Style="width:100%;">Name</MudTh>
        <MudTh>Length</MudTh>
        <MudTh Style="text-align:center;">Actions</MudTh>
      </HeaderContent>
      <RowTemplate>
        <MudTd DataLabel="Name" Style="word-break:break-all;">
          @context.Name
        </MudTd>
        <MudTd DataLabel="Length" Style="white-space:nowrap">
          @FormatSize(context.Length)
        </MudTd>
        <MudTd DataLabel="Actions" Style="text-align:end;">
          <MudStack Row="true" Style="gap:5px;">
            <MudButton Variant="Variant.Filled" Color="Color.Secondary" Size="Size.Small" OnClick="() => DeleteFile(context)">Delete</MudButton>
          </MudStack>
        </MudTd>
      </RowTemplate>
    </MudTable>

  </MudStack>
}

<style type="text/css" media="screen and (max-width:599px)">
  .mud-xs-table .mud-table-cell::before {
    word-break: keep-all !important;
    min-width: 55px !important;
  }

  .sv-custom-progress-stack {
    width: 100% !important;
  }

  .sv-table {
    margin: 5px !important;
    padding: 5px !important;
  }

  .sv-paper {
    margin: 5px !important;
    padding: 5px !important;
  }

  .sv-main-stack {
    gap: 3px !important;
  }

  .mud-xs-table.mud-table-dense .mud-table-cell {
    padding: 6px;
  }

  .sv-table-custom-row-1 {
    justify-content: start !important;
  }

  .mud-table-dense * .mud-table-row .mud-table-cell:last-child {
    padding-right: 0;
    padding-inline-end: 0;
  }
</style>

@code {
  [Inject] public required AppDbContext _context { get; set; }
  [Inject] private PersistentComponentState _persistentState { get; set; } = default!;
  [Inject] public required DownloadStateService DownloadState { get; set; }
  [Inject] private HttpClient _httpClient { get; set; } = default!;
  [Inject] public IDownloadQueueService DownloadQueueService { get; set; } = default!;
  [Inject] private NavigationManager NavigationManager { get; set; } = default!;

  private bool _isFullyLoaded;
  private PersistingComponentStateSubscription persistingSubscription;

  private HubConnection? hubConnection;

  private string UrlText { get; set; } = "";
  private string ErrorMessage { get; set; } = "";

  private List<FileDownloadQueueItem> _fileDownloadQueueItems = new();
  private bool _isLoadingTheList = false;

  private List<FileItem> _downloadDirectoryContents = new();

  protected override async Task OnInitializedAsync()
  {
    persistingSubscription = _persistentState.RegisterOnPersisting(PersistItems);

    // Loading downloads list
    if (_persistentState.TryTakeFromJson<List<FileDownloadQueueItem>>(nameof(_fileDownloadQueueItems), out var savedItems) && savedItems != null)
    {
      _fileDownloadQueueItems = savedItems;
    }
    else
    {
      await LoadDownloadItemsList();
    }

    // Loading download directory files list
    if (_persistentState.TryTakeFromJson<List<FileItem>>(nameof(_downloadDirectoryContents), out var savedItems2) && savedItems2 != null)
    {
      _downloadDirectoryContents = savedItems2;
    }
    else
    {
      LoadDownloadDirectoryContentsList();
    }

    await InitializeHubConnection();
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    await base.OnAfterRenderAsync(firstRender);

    if (!firstRender) return;
    // if (firstRender) return;
    if (_isFullyLoaded) return;

    _isFullyLoaded = true;
    await InvokeAsync(StateHasChanged);
  }

  public async ValueTask DisposeAsync()
  {
    persistingSubscription.Dispose();

    if (hubConnection is not null)
    {
      await hubConnection.DisposeAsync();
    }
  }

  private Task PersistItems()
  {
    _persistentState.PersistAsJson(nameof(_fileDownloadQueueItems), _fileDownloadQueueItems);
    _persistentState.PersistAsJson(nameof(_downloadDirectoryContents), _downloadDirectoryContents);
    return Task.CompletedTask;
  }

  private async Task InitializeHubConnection()
  {
    // Get Basic Auth credentials from environment variables or configuration
    var basicAuthUsername = Environment.GetEnvironmentVariable("BASIC_AUTH_USERNAME");
    var basicAuthPassword = Environment.GetEnvironmentVariable("BASIC_AUTH_PASSWORD");

    if (!string.IsNullOrWhiteSpace(basicAuthUsername) && !string.IsNullOrWhiteSpace(basicAuthPassword))
    {
      string credentials = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes($"{basicAuthUsername}:{basicAuthPassword}"));

      hubConnection = new HubConnectionBuilder()
        .WithUrl(NavigationManager.ToAbsoluteUri("/DownloadProgressHub"), options => options.Headers.Add("Authorization", $"Basic {credentials}"))
        .WithAutomaticReconnect()
        .Build();
    }
    else
    {
      hubConnection = new HubConnectionBuilder()
        .WithUrl(NavigationManager.ToAbsoluteUri("/DownloadProgressHub"))
        .WithAutomaticReconnect()
        .Build();
    }

    hubConnection.On<DownloadProgress>("DownloadProgressUpdate", OnDownloadProgressUpdate);

    await hubConnection.StartAsync();
  }

  private void OnDownloadProgressUpdate(DownloadProgress update)
  {
    var item = _fileDownloadQueueItems.FirstOrDefault(x => x.Id == update.ItemId);
    if (item != null)
    {
      item.ProgressPercentage = update.ProgressPercentage;
      item.CurrentDownloadSpeed = update.CurrentSpeed;
      item.AverageDownloadSpeed = update.AverageSpeed;
      LoadDownloadDirectoryContentsList(); // Temporary! To Do: Implement notifications for cancellation and finishing of downloads
      InvokeAsync(StateHasChanged);
    }
  }

  private async Task LoadDownloadItemsList()
  {
    try
    {
      _isLoadingTheList = true;
      _fileDownloadQueueItems = await DownloadQueueService.GetQueueItemsAsync();
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Getting Items List: {exception.Message}";
    }
    finally
    {
      _isLoadingTheList = false;
    }
  }

  private void LoadDownloadDirectoryContentsList()
  {
    try
    {
      _downloadDirectoryContents = DirectoryBrowser.GetDownloadsContent().OfType<FileItem>().ToList();
    }
    catch /* (DirectoryAccessException ex) */
    {
      throw;
    }
  }

  public async Task AddURL()
  {
    if (!string.IsNullOrWhiteSpace(UrlText))
    {
      try
      {
        var newFileDownload = new FileDownloadQueueItem() { InputUrl = UrlText };
        _context.FileDownloadQueueItems.Add(newFileDownload);
        await _context.SaveChangesAsync();

        ClearErrorMessage();

        await LoadDownloadItemsList();
      }
      catch (Exception exception)
      {
        ErrorMessage = $"An Error Occurred While Adding The URL: {exception.Message}";
      }
    }
    else
    {
      ErrorMessage = "Please Enter A Valid URL";
    }

    UrlText = "";
  }

  private void ClearErrorMessage()
  {
    ErrorMessage = "";
  }

  private async Task StartDownload(FileDownloadQueueItem item)
  {
    try
    {
      await DownloadQueueService.StartDownloadAsync(item.Id);
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Trying To Download: {exception.Message}";
    }
  }

  private async Task CancelDownload(FileDownloadQueueItem item)
  {
    if (DownloadState.TryGetTokenSource(item.Id, out var tokenSource))
    {
      tokenSource?.Cancel();
      DownloadState.RemoveTokenSource(item.Id);
    }

    item.Status = EQueueItemStatus.Cancelled;
    await _context.SaveChangesAsync();
    await LoadDownloadItemsList();
    LoadDownloadDirectoryContentsList();
  }

  private async Task DeleteItem(FileDownloadQueueItem item)
  {
    try
    {
      _context.FileDownloadQueueItems.Remove(item);
      DownloadState.RemoveTokenSource(item.Id);
      await _context.SaveChangesAsync();
      await LoadDownloadItemsList();
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Deleting The Item: {exception.Message}";
    }
  }

  private void DeleteFile(FileItem item)
  {
    try
    {
      DirectoryBrowser.DeleteFileItem(item);
      LoadDownloadDirectoryContentsList();
      StateHasChanged();
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Deleting The Item: {exception.Message}";
    }
  }

  private void ToggleMoreOptions(FileDownloadQueueItem item)
  {
    item.bShowMoreOptions = !item.bShowMoreOptions;
  }

  private string FormatSpeed(double speed)
  {
    if (speed == 0) return "0";
    else if (speed < 1024) return $"{speed:F2} B/s";
    else if (speed < 1024 * 1024) return $"{speed / 1024:F2} KB/s";
    else if (speed < 1024 * 1024 * 1024) return $"{speed / 1024 / 1024:F2} MB/s";
    else return $"{speed / 1024 / 1024 / 1024:F2} GB/s";
  }

  private string FormatSize(double size)
  {
    if (size == 0) return "0";
    else if (size < 1024) return $"{size:F2} B";
    else if (size < 1024 * 1024) return $"{size / 1024:F2} KB";
    else if (size < 1024 * 1024 * 1024) return $"{size / 1024 / 1024:F2} MB";
    else return $"{size / 1024 / 1024 / 1024:F2} GB";
  }

}
