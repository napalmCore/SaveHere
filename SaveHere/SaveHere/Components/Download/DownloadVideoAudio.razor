@implements IAsyncDisposable
@using Microsoft.EntityFrameworkCore
@using SaveHere.Components.Utility
@using SaveHere.Models
@using SaveHere.Models.SaveHere.Models
@using SaveHere.Models.db
@using SaveHere.Services
@using System.Net
@using Microsoft.AspNetCore.SignalR.Client

@inject AppDbContext _context
@inject PersistentComponentState _persistentState
@inject DownloadStateService DownloadState
@inject NavigationManager NavigationManager
@inject IYtdlpService YtdlpService
@inject IYoutubeDownloadQueueService YoutubeDownloadQueueService
@inject IDialogService DialogService

@rendermode InteractiveServer
@attribute [StreamRendering]

<MudPopoverProvider />
<MudDialogProvider />
<MudSnackbarProvider />

@if (!_isFullyLoaded)
{
  <div style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%;">
    <div style="position: relative;">
      <MudProgressCircular Color="Color.Success" Indeterminate="true" Class="ma-5" Style="width: 100px; height: 100px;" />
      <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -66%); text-align: center;">
        <div style="font-size: 12px;">Loading</div>
        <div style="font-size: 12px">Please Wait</div>
      </div>
    </div>
  </div>
}
else
{
  <MudPaper Class="px-5 py-4 mx-5 mt-5 sv-paper" Elevation="5">
    <MudStack Row>
      <MudTextField @bind-Value="YoutubeUrl"
                    Label="Video/Audio URL"
                    Variant="Variant.Outlined"
                    Margin="Margin.Dense"
                    HelperText="Enter Video/Audio URL"
                    HelperTextOnFocus="true"
                    Adornment="Adornment.End"
                    AdornmentIcon="@Icons.Custom.Brands.YouTube"
                    AdornmentColor="Color.Error"
                    Clearable="true"
                    Immediate="true"
                    TextUpdateSuppression="false"
                    @onkeydown="HandleUrlInputKeyDown" />

      <MudButton Variant="Variant.Filled"
                 StartIcon="@Icons.Material.Filled.Add"
                 Color="Color.Error"
                 Style="text-transform:none; height:40px; margin-top:0.5rem;"
                 Class="pr-5"
                 Size="Size.Small"
                 OnClick="AddDownload">
        Add
      </MudButton>
    </MudStack>

    <MudStack Row>
      <MudTextField @bind-Value="ProxyUrl"
                    Label="Proxy Server"
                    Variant="Variant.Outlined"
                    Margin="Margin.Dense" />

      <MudSelect @bind-Value="SelectedQuality"
                 Label="Video Quality"
                 Variant="Variant.Outlined"
                 Margin="Margin.Dense">
        <MudSelectItem Value="@("Best")">Best Quality</MudSelectItem>
        <MudSelectItem Value="@("bestvideo[height<=1080]+bestaudio/best")">1080p or lower</MudSelectItem>
        <MudSelectItem Value="@("bestvideo[height<=720]+bestaudio/best")">720p or lower</MudSelectItem>
        <MudSelectItem Value="@("Worst")">Worst Quality</MudSelectItem>
      </MudSelect>
    </MudStack>

    <MudText Typo="Typo.subtitle2" Class="mt-3 mx-3">
      This component uses ytdlp to download video/audio. See
      <MudLink OnClick="OpenSupportedSites"
               Target="_blank"
               Color="Color.Primary"
               Typo="Typo.subtitle2">
        Supported Sites
      </MudLink>
    </MudText>
  </MudPaper>

  @if (!string.IsNullOrWhiteSpace(ErrorMessage))
  {
    <MudAlert Severity="Severity.Error" Variant="Variant.Outlined" Dense="true" Elevation="10" ContentAlignment="HorizontalAlignment.Center" Class="mt-3 mx-5" ShowCloseIcon="true" CloseIconClicked="ClearErrorMessage">
      @ErrorMessage
    </MudAlert>
  }

  @if (_youtubeDownloadQueueItems is not null && _youtubeDownloadQueueItems.Any())
  {
    <MudPaper Class="px-5 py-4 mx-5 mt-3 sv-paper" Elevation="5">
      <MudStack>
        @foreach (var download in _youtubeDownloadQueueItems)
        {
          <MudPaper Elevation="0" Class="pt-4">
            <MudStack>
              <MudText Style="word-break:break-all;"><strong>URL:</strong> @download.Url</MudText>

              <MudStack Row="true" Style="display: flex; justify-content:space-between;">
                <MudStack Row="true" Class="align-center">
                  <MudText><strong>Status:</strong></MudText>
                  @if (download.Status == EQueueItemStatus.Downloading)
                  {
                    <MudChip Color="Color.Info" Size="Size.Small" T="string">Downloading</MudChip>
                  }
                  else if (download.Status == EQueueItemStatus.Finished)
                  {
                    <MudChip Color="Color.Success" Size="Size.Small" T="string">Completed</MudChip>
                  }
                  else if (download.Status == EQueueItemStatus.Cancelled)
                  {
                    <MudChip Color="Color.Error" Size="Size.Small" T="string">Cancelled</MudChip>
                  }
                  else
                  {
                    <MudChip Color="Color.Warning" Size="Size.Small" T="string">Paused</MudChip>
                  }
                </MudStack>

                <MudStack Row="true">
                  @if (download.Status == EQueueItemStatus.Downloading)
                  {
                    <MudButton Variant="Variant.Filled"
                               Color="Color.Error"
                               Size="Size.Small"
                               OnClick="() => CancelDownload(download)">
                      Cancel
                    </MudButton>
                  }
                  else if (download.Status != EQueueItemStatus.Finished && download.Status != EQueueItemStatus.Downloading)
                  {
                    <MudButton Variant="Variant.Filled"
                               Color="Color.Success"
                               Size="Size.Small"
                               OnClick="() => StartDownload(download)">
                      Start
                    </MudButton>
                  }
                  <MudButton Variant="Variant.Filled"
                             Color="Color.Error"
                             Size="Size.Small"
                             OnClick="() => RemoveDownload(download)">
                    Remove
                  </MudButton>
                </MudStack>
              </MudStack>

              <MudPaper Height="200px" Class="pa-1" Style="width:100%; overflow-y: auto; background-color: #01010155;">
                <MudStack>
                  @foreach (var line in download.OutputLog)
                  {
                    <MudText Color="Color.Inherit" Style="font-family: monospace; font-size: 0.75rem;">@line</MudText>
                  }
                </MudStack>
              </MudPaper>
            </MudStack>
          </MudPaper>
        }
      </MudStack>
    </MudPaper>
  }

  <FileManager @ref="fileManager" />
}

<style type="text/css" media="screen and (max-width:599px)">
  .sv-paper {
    margin: 5px !important;
    padding: 5px !important;
  }

  .sv-main-stack {
    gap: 3px !important;
  }
</style>

@code {
  private FileManager? fileManager;
  private bool _isFullyLoaded;
  private PersistingComponentStateSubscription persistingSubscription;
  private HubConnection? hubConnection;

  private string YoutubeUrl { get; set; } = "";
  private string ProxyUrl { get; set; } = @"http://localhost:8086";
  private string SelectedQuality { get; set; } = "Best";
  private string ErrorMessage { get; set; } = "";

  private List<YoutubeDownloadQueueItem> _youtubeDownloadQueueItems = new();
  private bool _isLoadingTheList = false;

  private DateTime _lastUiUpdateTime = DateTime.MinValue;
  private TimeSpan _uiUpdateInterval = TimeSpan.FromSeconds(1);

  protected override async Task OnInitializedAsync()
  {
    persistingSubscription = _persistentState.RegisterOnPersisting(PersistItems);

    // Loading downloads list
    if (_persistentState.TryTakeFromJson<List<YoutubeDownloadQueueItem>>(nameof(_youtubeDownloadQueueItems), out var savedItems) && savedItems != null)
    {
      _youtubeDownloadQueueItems = savedItems;
    }
    else
    {
      await LoadDownloadItemsList();
    }

    await InitializeHubConnection();
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    await base.OnAfterRenderAsync(firstRender);

    if (!firstRender) return;
    if (_isFullyLoaded) return;

    _isFullyLoaded = true;
    await InvokeAsync(StateHasChanged);
  }

  public async ValueTask DisposeAsync()
  {
    persistingSubscription.Dispose();

    if (hubConnection is not null)
    {
      await hubConnection.DisposeAsync();
    }
  }

  private Task PersistItems()
  {
    _persistentState.PersistAsJson(nameof(_youtubeDownloadQueueItems), _youtubeDownloadQueueItems);
    return Task.CompletedTask;
  }

  private async Task InitializeHubConnection()
  {
    // Get Basic Auth credentials from environment variables or configuration
    var basicAuthUsername = Environment.GetEnvironmentVariable("BASIC_AUTH_USERNAME");
    var basicAuthPassword = Environment.GetEnvironmentVariable("BASIC_AUTH_PASSWORD");

    if (!string.IsNullOrWhiteSpace(basicAuthUsername) && !string.IsNullOrWhiteSpace(basicAuthPassword))
    {
      string credentials = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes($"{basicAuthUsername}:{basicAuthPassword}"));

      hubConnection = new HubConnectionBuilder()
        .WithUrl(NavigationManager.ToAbsoluteUri("/DownloadProgressHub"), options => options.Headers.Add("Authorization", $"Basic {credentials}"))
        .WithAutomaticReconnect()
        .Build();
    }
    else
    {
      hubConnection = new HubConnectionBuilder()
        .WithUrl(NavigationManager.ToAbsoluteUri("/DownloadProgressHub"))
        .WithAutomaticReconnect()
        .Build();
    }

    hubConnection.On<int, string>("DownloadStateChanged", OnDownloadStateUpdateAsync);
    hubConnection.On<int, string>("DownloadLogUpdate", OnDownloadLogUpdateAsync);

    try
    {
      await hubConnection.StartAsync();
    }
    catch (Exception ex)
    {
      ErrorMessage = $"Failed to connect to progress updates: {ex.Message}";
    }
  }

  private async Task OnDownloadStateUpdateAsync(int itemId, string newStatus)
  {
    var item = _youtubeDownloadQueueItems.FirstOrDefault(x => x.Id == itemId);
    if (item != null)
    {
      await InvokeAsync(() =>
      {
        item.Status = Enum.Parse<EQueueItemStatus>(newStatus);
        if (newStatus != EQueueItemStatus.Downloading.ToString())
        {
          ThrottleUIUpdate(true);
        }
      });
    }
    else
    {
      await LoadDownloadItemsList();
      ThrottleUIUpdate(true);
    }
  }

  private async Task OnDownloadLogUpdateAsync(int itemId, string logLine)
  {
    var item = _youtubeDownloadQueueItems.FirstOrDefault(x => x.Id == itemId);
    if (item != null)
    {
      await InvokeAsync(() =>
      {
        item.OutputLog.Add(logLine);
        ThrottleUIUpdate();
      });
      await YoutubeDownloadQueueService.AppendLogAsync(itemId, logLine);
    }
    else
    {
      await LoadDownloadItemsList();
      ThrottleUIUpdate(true);
    }
  }


  private async Task LoadDownloadItemsList()
  {
    try
    {
      _isLoadingTheList = true;
      _youtubeDownloadQueueItems = await YoutubeDownloadQueueService.GetQueueItemsAsync();
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Getting Items List: {exception.Message}";
    }
    finally
    {
      _isLoadingTheList = false;
    }
  }

  private async Task AddDownload()
  {
    if (string.IsNullOrWhiteSpace(YoutubeUrl))
    {
      ErrorMessage = "Please enter a YouTube URL";
      return;
    }

    try
    {
      var newYoutubeDownload = await YoutubeDownloadQueueService.AddQueueItemAsync(YoutubeUrl, SelectedQuality, ProxyUrl);
      YoutubeUrl = "";
      ErrorMessage = "";
      await LoadDownloadItemsList();
      ThrottleUIUpdate();
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Adding The URL: {exception.Message}";
    }
  }

  private void ClearErrorMessage()
  {
    ErrorMessage = "";
  }

  private async Task StartDownload(YoutubeDownloadQueueItem item)
  {
    try
    {
      await YoutubeDownloadQueueService.StartDownloadAsync(item.Id);
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Trying To Download: {exception.Message}";
    }
  }

  private async Task CancelDownload(YoutubeDownloadQueueItem item)
  {
    try
    {
      await YoutubeDownloadQueueService.CancelDownloadAsync(item.Id);
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Canceling The Download: {exception.Message}";
    }
  }

  private async Task RemoveDownload(YoutubeDownloadQueueItem item)
  {
    try
    {
      await YoutubeDownloadQueueService.DeleteQueueItemAsync(item.Id);
      await LoadDownloadItemsList();
      ThrottleUIUpdate(true);
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Deleting The Item: {exception.Message}";
    }
  }

  private async Task HandleUrlInputKeyDown(KeyboardEventArgs e)
  {
    if (e.Key == "Enter")
    {
      await AddDownload();
    }
  }

  private async Task RefreshFileManager()
  {
    try
    {
      if (fileManager is not null)
      {
        await fileManager.RefreshFiles();
      }
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Refreshing Files: {exception.Message}";
    }
  }

  private void ThrottleUIUpdate(bool forceUpdate = false)
  {
    var now = DateTime.Now;
    if (forceUpdate || (now - _lastUiUpdateTime >= _uiUpdateInterval))
    {
      _lastUiUpdateTime = now;
      InvokeAsync(StateHasChanged);
      InvokeAsync(RefreshFileManager);
    }
  }

  private void OpenSupportedSites()
  {
    var options = new DialogOptions
      {
        MaxWidth = MaxWidth.Large,
        FullWidth = true,
        CloseButton = true
      };

    DialogService.Show<MarkdownViewerDialog>("Supported Sites", options);
  }

}