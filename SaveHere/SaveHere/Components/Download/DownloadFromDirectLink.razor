@implements IAsyncDisposable

@using Microsoft.EntityFrameworkCore
@using SaveHere.Components.Utility
@using SaveHere.Models
@using SaveHere.Models.db
@using SaveHere.Services
@using SaveHere.Helpers
@using System.Net
@using System.Diagnostics
@using Microsoft.AspNetCore.SignalR.Client

@rendermode InteractiveServer
@attribute [StreamRendering]

<MudPopoverProvider />
<MudDialogProvider />
<MudSnackbarProvider />

  @if (!_isFullyLoaded)
{
  <div style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%;">
    <div style="position: relative;">
      <MudProgressCircular Color="Color.Success" Indeterminate="true" Class="ma-5" Style="width: 100px; height: 100px;" />
      <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -66%); text-align: center;">
        <div style="font-size: 12px;">Loading</div>
        <div style="font-size: 12px">Please Wait</div>
      </div>
    </div>
  </div>
}
else
{
  <MudPaper Class="px-5 pt-4 mx-5 mt-5 sv-paper" Elevation="5">

    <MudStack Row>

      <MudTextField @bind-Value="UrlText" Label="File URL" Variant="Variant.Outlined" Margin="Margin.Dense"
                    HelperText="Enter The File URL To Upload To The Server" HelperTextOnFocus="true" Adornment="Adornment.End"
                    AdornmentIcon="@Icons.Material.Filled.InsertLink" AdornmentColor="Color.Info" Clearable="true"
                    Immediate="true" @onkeydown="HandleUrlInputKeyDown" TextUpdateSuppression="false" />

      <MudButton Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Add" Color="Color.Primary"
                 Style="text-transform:none; height:40px; margin-top:0.5rem;" Class="pr-5" Size="Size.Small" OnClick="AddURL">Add</MudButton>

    </MudStack>

  </MudPaper>

  @if (!string.IsNullOrWhiteSpace(ErrorMessage))
  {
    <MudAlert Severity="Severity.Error" Variant="Variant.Outlined" Dense="true" Elevation="10" ContentAlignment="HorizontalAlignment.Center" Class="mt-3 mx-5" ShowCloseIcon="true" CloseIconClicked="ClearErrorMessage">
      @ErrorMessage
    </MudAlert>
  }

  @if (_fileDownloadQueueItems is not null && _fileDownloadQueueItems.Any())
  {
    <MudTable Items="@_fileDownloadQueueItems" Dense="true" Hover="true" Loading="@_isLoadingTheList" Class="mt-3 pa-5 mx-5 sv-table" Elevation="5">
      <HeaderContent>
        <MudTh Style="width:100%;">URL</MudTh>
        <MudTh Style="text-align:center; min-width:125px;">Status</MudTh>
        <MudTh Style="text-align:center; min-width:200px;">Progress</MudTh>
        <MudTh Style="text-align:center;">Actions</MudTh>
      </HeaderContent>
      <RowTemplate>
        <MudTd Style="word-break:break-all;" DataLabel="URL" Class="sv-table-custom-row-1">
          @context.InputUrl
        </MudTd>
        <MudTd Style="text-align:center;" Class="sv-table-custom-row-1" DataLabel="Status">@context.Status</MudTd>
        <MudTd Style="text-align:center" class="sv-table-custom-row-1" DataLabel="Progress">
          <MudStack Spacing="0" Class="sv-custom-progress-stack">

            <div style="display:flex; justify-content:space-between;">
              <span style="font-size:0.66rem;">speed</span>
              <MudText Typo="Typo.body2" Align="Align.Left" Class="ma-0 pa-0" Style="white-space:nowrap">
                @Helpers.FormatSpeed(context.CurrentDownloadSpeed)
              </MudText>
            </div>

            <MudStack Row="true" Spacing="1" Justify="Justify.SpaceBetween">
              <MudProgressLinear Value="@context.ProgressPercentage" Color="Color.Tertiary" Striped="@(context.Status==EQueueItemStatus.Downloading)" Class="ma-0 pa-0 sv-progressbar" Style="width: 100%;" Size="Size.Large" />

              <MudText Typo="Typo.inherit" Color="Color.Warning" Class="ma-0 pa-0" Align="Align.Right" Inline="true" Style="font-size:10px;">
                @context.ProgressPercentage%
              </MudText>
            </MudStack>

            <div style="display:flex; justify-content:space-between;">
              <span style="font-size:0.66rem;">average</span>
              <MudText Typo="Typo.body2" Align="Align.Left" Class="ma-0 pa-0" Style="white-space:nowrap">
                @Helpers.FormatSpeed(context.AverageDownloadSpeed)
              </MudText>
            </div>

          </MudStack>
        </MudTd>
        <MudTd Style="text-align:end;" Class="sv-table-custom-row-1" DataLabel="Actions">
          <MudStack Row="true" Style="gap:5px;">
            <MudButton Variant="Variant.Filled" Color="@(context.Status==EQueueItemStatus.Downloading?Color.Error:Color.Success)" Size="Size.Small" Style="min-width:75px;" OnClick="async() =>
            {
            if (context.Status==EQueueItemStatus.Downloading) await CancelDownload(context); else await StartDownload(context);
            }">
              @(context.Status == EQueueItemStatus.Downloading ? "Stop" : "Start")
            </MudButton>
            <MudButton Variant="Variant.Filled" Color="Color.Secondary" Size="Size.Small" OnClick="async() => await DeleteQueueItem(context)">Delete</MudButton>
            <MudButton Variant="Variant.Filled" Color="Color.Info" Size="Size.Small" OnClick="() => ToggleMoreOptions(context)">@(context.bShowMoreOptions ? "Collapse" : "Options")</MudButton>
          </MudStack>
        </MudTd>
      </RowTemplate>
      <ChildRowContent>
        @if (context.bShowMoreOptions)
        {
          <MudTr Style="justify-content: start;">
            <MudTd ColSpan="4" Style="justify-content: start; width:100%;">
              <MudPaper Class="pa-5" Elevation="0" Outlined="true" Style="start; width:100%;">
                <MudStack>
                  <MudCheckBox @bind-Value="@context.bShouldGetFilenameFromHttpHeaders" Label="Use Headers For Filename" Color="Color.Primary" />
                </MudStack>
              </MudPaper>
            </MudTd>
          </MudTr>
        }
      </ChildRowContent>
    </MudTable>
  }

  <FileManager @ref="fileManager" />
}

<style type="text/css" media="screen and (max-width:599px)">
  .mud-xs-table .mud-table-cell::before {
    word-break: keep-all !important;
    min-width: 55px !important;
  }

  .sv-custom-progress-stack {
    width: 100% !important;
  }

  .sv-table {
    margin: 5px !important;
    padding: 5px !important;
  }

  .sv-paper {
    margin: 5px !important;
    padding: 5px !important;
  }

  .sv-main-stack {
    gap: 3px !important;
  }

  .mud-xs-table.mud-table-dense .mud-table-cell {
    padding: 6px;
  }

  .sv-table-custom-row-1 {
    justify-content: start !important;
  }

  .mud-table-dense * .mud-table-row .mud-table-cell:last-child {
    padding-right: 0;
    padding-inline-end: 0;
  }
</style>

<style>
  .my-custom-media-dialog {
    backdrop-filter: blur(10px);
  }
</style>

@code {
  [Inject] public required AppDbContext _context { get; set; }
  [Inject] private PersistentComponentState _persistentState { get; set; } = default!;
  [Inject] public required DownloadStateService DownloadState { get; set; }
  [Inject] public IDownloadQueueService DownloadQueueService { get; set; } = default!;
  [Inject] private NavigationManager NavigationManager { get; set; } = default!;
  [Inject] private IDialogService DialogService { get; set; } = default!;

  private bool _isFullyLoaded;
  private PersistingComponentStateSubscription persistingSubscription;

  private HubConnection? hubConnection;

  private FileManager? fileManager;

  private string UrlText { get; set; } = "";
  private string ErrorMessage { get; set; } = "";

  private List<FileDownloadQueueItem> _fileDownloadQueueItems = new();
  private bool _isLoadingTheList = false;

  protected override async Task OnInitializedAsync()
  {
    persistingSubscription = _persistentState.RegisterOnPersisting(PersistItems);

    // Loading downloads list
    if (_persistentState.TryTakeFromJson<List<FileDownloadQueueItem>>(nameof(_fileDownloadQueueItems), out var savedItems) && savedItems != null)
    {
      _fileDownloadQueueItems = savedItems;
    }
    else
    {
      await LoadDownloadItemsList();
    }

    await InitializeHubConnection();
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    await base.OnAfterRenderAsync(firstRender);

    if (!firstRender) return;
    if (_isFullyLoaded) return;

    _isFullyLoaded = true;
    await InvokeAsync(StateHasChanged);
  }

  public async ValueTask DisposeAsync()
  {
    persistingSubscription.Dispose();

    if (hubConnection is not null)
    {
      await hubConnection.DisposeAsync();
    }
  }

  private Task PersistItems()
  {
    _persistentState.PersistAsJson(nameof(_fileDownloadQueueItems), _fileDownloadQueueItems);
    return Task.CompletedTask;
  }

  private async Task InitializeHubConnection()
  {
    // Get Basic Auth credentials from environment variables or configuration
    var basicAuthUsername = Environment.GetEnvironmentVariable("BASIC_AUTH_USERNAME");
    var basicAuthPassword = Environment.GetEnvironmentVariable("BASIC_AUTH_PASSWORD");

    if (!string.IsNullOrWhiteSpace(basicAuthUsername) && !string.IsNullOrWhiteSpace(basicAuthPassword))
    {
      string credentials = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes($"{basicAuthUsername}:{basicAuthPassword}"));

      hubConnection = new HubConnectionBuilder()
        .WithUrl(NavigationManager.ToAbsoluteUri("/DownloadProgressHub"), options => options.Headers.Add("Authorization", $"Basic {credentials}"))
        .WithAutomaticReconnect()
        .Build();
    }
    else
    {
      hubConnection = new HubConnectionBuilder()
        .WithUrl(NavigationManager.ToAbsoluteUri("/DownloadProgressHub"))
        .WithAutomaticReconnect()
        .Build();
    }

    hubConnection.On<DownloadProgress>("DownloadProgressUpdate", OnDownloadProgressUpdateAsync);
    hubConnection.On<int, string>("DownloadStateChanged", OnDownloadStateUpdateAsync);

    try
    {
      await hubConnection.StartAsync();

      // Subscribe to updates for all current downloads
      // if (_fileDownloadQueueItems != null)
      // {
      //   foreach (var item in _fileDownloadQueueItems.Where(x => x.Status == EQueueItemStatus.Downloading))
      //   {
      //     await hubConnection.SendAsync("SubscribeToDownload", item.Id);
      //   }
      // }
    }
    catch (Exception ex)
    {
      ErrorMessage = $"Failed to connect to progress updates: {ex.Message}";
    }
  }

  private async Task OnDownloadProgressUpdateAsync(DownloadProgress update)
  {
    var item = _fileDownloadQueueItems.FirstOrDefault(x => x.Id == update.ItemId);
    if (item != null)
    {
      item.ProgressPercentage = update.ProgressPercentage;
      item.CurrentDownloadSpeed = update.CurrentSpeed;
      item.AverageDownloadSpeed = update.AverageSpeed;

      await RefreshFileManager();

      await InvokeAsync(StateHasChanged);
    }
    else
    {
      // If we don't have the item in our list, refresh the whole list
      await LoadDownloadItemsList();
      await InvokeAsync(StateHasChanged);
    }
  }

  private async Task OnDownloadStateUpdateAsync(int itemId, string newStatus)
  {
    var item = _fileDownloadQueueItems.FirstOrDefault(x => x.Id == itemId);
    if (item != null)
    {
      await InvokeAsync(() =>
      {
        item.Status = Enum.Parse<EQueueItemStatus>(newStatus);
        if (newStatus != EQueueItemStatus.Downloading.ToString())
        {
          InvokeAsync(RefreshFileManager);
        }
        StateHasChanged();
      });
    }
    else
    {
      await LoadDownloadItemsList();
      await InvokeAsync(StateHasChanged);
    }
  }

  private async Task LoadDownloadItemsList()
  {
    try
    {
      _isLoadingTheList = true;
      var items = await DownloadQueueService.GetQueueItemsAsync();

      // Update the list while preserving existing items to prevent UI flicker
      foreach (var newItem in items)
      {
        var existingItem = _fileDownloadQueueItems.FirstOrDefault(x => x.Id == newItem.Id);
        if (existingItem != null)
        {
          existingItem.Status = newItem.Status;
          existingItem.ProgressPercentage = newItem.ProgressPercentage;
          existingItem.CurrentDownloadSpeed = newItem.CurrentDownloadSpeed;
          existingItem.AverageDownloadSpeed = newItem.AverageDownloadSpeed;
        }
        else
        {
          _fileDownloadQueueItems.Add(newItem);
        }
      }

      // Remove items that no longer exist
      _fileDownloadQueueItems.RemoveAll(x => !items.Any(y => y.Id == x.Id));
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Getting Items List: {exception.Message}";
    }
    finally
    {
      _isLoadingTheList = false;
    }
  }

  public async Task AddURL()
  {
    if (!string.IsNullOrWhiteSpace(UrlText))
    {
      try
      {
        var newFileDownload = new FileDownloadQueueItem() { InputUrl = UrlText };
        _context.FileDownloadQueueItems.Add(newFileDownload);
        await _context.SaveChangesAsync();

        UrlText = "";
        StateHasChanged();

        await LoadDownloadItemsList();
      }
      catch (Exception exception)
      {
        ErrorMessage = $"An Error Occurred While Adding The URL: {exception.Message}";
      }
    }
    else
    {
      ErrorMessage = "Please Enter A Valid URL";
    }
  }

  private void ClearErrorMessage()
  {
    ErrorMessage = "";
  }

  private async Task StartDownload(FileDownloadQueueItem item)
  {
    try
    {
      await DownloadQueueService.StartDownloadAsync(item.Id);
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Trying To Download: {exception.Message}";
    }
  }

  private async Task CancelDownload(FileDownloadQueueItem item)
  {
    try
    {
      await DownloadQueueService.CancelDownloadAsync(item.Id);
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Canceling The Download: {exception.Message}";
    }
  }

  private async Task DeleteQueueItem(FileDownloadQueueItem item)
  {
    try
    {
      var itemToDelete = await _context.FileDownloadQueueItems.FindAsync(item.Id);
      if (itemToDelete != null)
      {
        _context.FileDownloadQueueItems.Remove(itemToDelete);
        DownloadState.RemoveTokenSource(item.Id);
        await _context.SaveChangesAsync();
        await LoadDownloadItemsList();
      }
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Deleting The Item: {exception.Message}";
    }
  }

  private void ToggleMoreOptions(FileDownloadQueueItem item)
  {
    item.bShowMoreOptions = !item.bShowMoreOptions;
  }

  private async Task HandleUrlInputKeyDown(KeyboardEventArgs e)
  {
    if (e.Key == "Enter")
    {
      await AddURL();
    }
  }

  private async Task RefreshFileManager()
  {
    try
    {
      if (fileManager is not null)
      {
        await fileManager.RefreshFiles();
      }
    }
    catch (Exception exception)
    {
      ErrorMessage = $"An Error Occurred While Refreshing Files: {exception.Message}";
    }
  }

}
