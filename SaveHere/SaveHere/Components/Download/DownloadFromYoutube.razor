@implements IDisposable
@using SaveHere.Components.File
@using SaveHere.Models
@using SaveHere.Services
@inject IYtdlpService YtdlpService

@rendermode InteractiveServer
@attribute [StreamRendering]

<MudPopoverProvider />
<MudDialogProvider />
<MudSnackbarProvider />

<MudPaper Class="px-5 pt-4 mx-5 mt-5 sv-paper" Elevation="5">
  <MudStack Row>
    <MudTextField @bind-Value="YoutubeUrl"
                  Label="YouTube URL"
                  Variant="Variant.Outlined"
                  Margin="Margin.Dense"
                  HelperText="Enter YouTube Video URL"
                  HelperTextOnFocus="true"
                  Adornment="Adornment.End"
                  AdornmentIcon="@Icons.Custom.Brands.YouTube"
                  AdornmentColor="Color.Error"
                  Clearable="true"
                  Immediate="true"
                  TextUpdateSuppression="false"
                  @onkeydown="HandleUrlInputKeyDown" />

    <MudButton Variant="Variant.Filled"
               StartIcon="@Icons.Material.Filled.Add"
               Color="Color.Error"
               Style="text-transform:none; height:40px; margin-top:0.5rem;"
               Class="pr-5"
               Size="Size.Small"
               OnClick="AddDownload">
      Add
    </MudButton>
  </MudStack>

  <MudStack Row>
    <MudTextField @bind-Value="ProxyUrl"
                  Label="Proxy Server"
                  Variant="Variant.Outlined"
                  Margin="Margin.Dense"
                  HelperText="@("e.g. http://1.2.3.4:56")" />

    <MudSelect @bind-Value="SelectedQuality"
               Label="Video Quality"
               Variant="Variant.Outlined"
               Margin="Margin.Dense">
      <MudSelectItem Value="@("Best")">Best Quality</MudSelectItem>
      <MudSelectItem Value="@("bestvideo[height<=1080]+bestaudio/best")">1080p or lower</MudSelectItem>
      <MudSelectItem Value="@("bestvideo[height<=720]+bestaudio/best")">720p or lower</MudSelectItem>
      <MudSelectItem Value="@("Worst")">Worst Quality</MudSelectItem>
    </MudSelect>
  </MudStack>

  @if (ActiveDownloads > 0)
  {
    <MudText Class="mt-2" Typo="Typo.body2">Active downloads: @ActiveDownloads</MudText>
  }
</MudPaper>

@if (Downloads.Any())
{
  <MudPaper Class="px-5 py-4 mx-5 mt-3 sv-paper" Elevation="5">
    <MudStack>
      @foreach (var download in Downloads)
      {
        <MudPaper Elevation="0" Class="pt-4">
          <MudStack>
            <MudText Style="word-break:break-all;"><strong>URL:</strong> @download.Url</MudText>

            <MudStack Row="true" Style="display: flex; justify-content:space-between;">
              <MudStack Row="true" Class="align-center">
                <MudText><strong>Status:</strong></MudText>
                @if (download.IsDownloading)
                {
                  <MudChip Color="Color.Info" Size="Size.Small" T="string">Downloading</MudChip>
                }
                else if (download.IsCompleted)
                {
                  <MudChip Color="Color.Success" Size="Size.Small" T="string">Completed</MudChip>
                }
                else
                {
                  <MudChip Color="Color.Warning" Size="Size.Small" T="string">Paused</MudChip>
                }
              </MudStack>

              <MudStack Row="true">
                @if (download.IsDownloading)
                {
                  <MudButton Variant="Variant.Filled"
                             Color="Color.Error"
                             Size="Size.Small"
                             OnClick="() => CancelDownload(download)">
                    Cancel
                  </MudButton>
                }
                else if (!download.IsCompleted)
                {
                  <MudButton Variant="Variant.Filled"
                             Color="Color.Success"
                             Size="Size.Small"
                             OnClick="() => RestartDownload(download)">
                    Start
                  </MudButton>
                }
                <MudButton Variant="Variant.Filled"
                           Color="Color.Error"
                           Size="Size.Small"
                           OnClick="() => RemoveDownload(download)">
                  Remove
                </MudButton>
              </MudStack>
            </MudStack>

            <MudPaper Height="200px" Class="pa-1" Style="width:100%; overflow-y: auto; background-color: #01010155;">
              <MudStack>
                @foreach (var line in download.OutputLog)
                {
                  <MudText Color="Color.Inherit" Style="font-family: monospace; font-size: 0.75rem;">@line</MudText>
                }
              </MudStack>
            </MudPaper>
          </MudStack>
        </MudPaper>
      }
    </MudStack>
  </MudPaper>
}

<FileManager @ref="fileManager" />

<style type="text/css" media="screen and (max-width:599px)">
  .sv-paper {
    margin: 5px !important;
    padding: 5px !important;
  }

  .sv-main-stack {
    gap: 3px !important;
  }
</style>

@code {
  private FileManager? fileManager;

  private string YoutubeUrl { get; set; } = "";
  private int MaxConcurrentDownloads { get; set; } = 3;
  private int ActiveDownloads => Downloads.Count(d => d.IsDownloading);
  private List<YoutubeDownloadItem> Downloads { get; set; } = new();

  private string ProxyUrl { get; set; } = @"http://localhost:8086";
  private string SelectedQuality { get; set; } = "Best";

  // protected override async Task OnInitializedAsync()
  // {
  //   try
  //   {
  //     await YtdlpService.EnsureYtdlpAvailable();
  //   }
  //   catch {/*pass for now*/}
  // }

  private void AddDownload()
  {
    if (string.IsNullOrWhiteSpace(YoutubeUrl))
    {
      // Snackbar.Add("Please enter a YouTube URL", Severity.Warning);
      return;
    }

    if (ActiveDownloads >= MaxConcurrentDownloads)
    {
      // Snackbar.Add($"Maximum of {MaxConcurrentDownloads} concurrent downloads allowed", Severity.Warning);
      return;
    }

    var download = new YoutubeDownloadItem
      {
        Url = YoutubeUrl,
        Proxy = ProxyUrl,
        Quality = SelectedQuality,
        IsDownloading = true,
        IsCompleted = false,
        CancellationTokenSource = new CancellationTokenSource()
      };

    Downloads.Add(download);
    YoutubeUrl = "";
    StateHasChanged();

    _ = Task.Run(async () =>
    {
      try
      {
        await YtdlpService.DownloadVideo(
            download.Url,
            download.Quality,
            download.Proxy,
            output =>
            {
              download.OutputLog.Add(output);
              InvokeAsync(StateHasChanged);
              InvokeAsync(RefreshFileManager);
            },
            download.CancellationTokenSource.Token
      );
        download.IsCompleted = true;
      }
      catch (OperationCanceledException)
      {
        download.OutputLog.Add("Download was cancelled.");
        // Snackbar.Add("Download cancelled", Severity.Info);
      }
      catch (Exception ex)
      {
        download.OutputLog.Add($"Error: {ex.Message}");
        // Snackbar.Add($"Download failed: {ex.Message}", Severity.Error);
      }
      finally
      {
        download.IsDownloading = false;
        download.CancellationTokenSource?.Dispose();
        download.CancellationTokenSource = null;
        await InvokeAsync(StateHasChanged);
      }
    });
  }

  private void RestartDownload(YoutubeDownloadItem download)
  {
    if (ActiveDownloads >= MaxConcurrentDownloads)
    {
      // Snackbar.Add($"Maximum of {MaxConcurrentDownloads} concurrent downloads allowed", Severity.Warning);
      return;
    }

    download.OutputLog.Clear();
    download.IsDownloading = true;
    download.IsCompleted = false;
    download.CancellationTokenSource = new CancellationTokenSource();

    _ = Task.Run(async () =>
    {
      try
      {
        await YtdlpService.DownloadVideo(
          download.Url,
          download.Quality,
          download.Proxy,
          output =>
          {
            download.OutputLog.Add(output);
            InvokeAsync(StateHasChanged);
            InvokeAsync(RefreshFileManager);
          },
          download.CancellationTokenSource.Token
      );
        download.IsCompleted = true;
      }
      catch (OperationCanceledException)
      {
        download.OutputLog.Add("Download was cancelled.");
      }
      catch (Exception ex)
      {
        download.OutputLog.Add($"Error: {ex.Message}");
      }
      finally
      {
        download.IsDownloading = false;
        download.CancellationTokenSource?.Dispose();
        download.CancellationTokenSource = null;
        await InvokeAsync(StateHasChanged);
      }
    });
  }

  private void RemoveDownload(YoutubeDownloadItem download)
  {
    CancelDownload(download);
    Downloads.Remove(download);
    download.CancellationTokenSource?.Dispose();
    StateHasChanged();
  }

  private void CancelDownload(YoutubeDownloadItem download)
  {
    if (download.IsDownloading && download.CancellationTokenSource != null)
    {
      download.CancellationTokenSource.Cancel();
      download.OutputLog.Add("Cancelling download...");
      StateHasChanged();

      InvokeAsync(RefreshFileManager);
    }
  }

  private void HandleUrlInputKeyDown(KeyboardEventArgs e)
  {
    if (e.Key == "Enter")
    {
      AddDownload();
    }
  }

  public void Dispose()
  {
    foreach (var download in Downloads)
    {
      download.CancellationTokenSource?.Cancel();
      download.CancellationTokenSource?.Dispose();
    }
  }

  private async Task RefreshFileManager()
  {
    try
    {
      if (fileManager is not null)
      {
        await fileManager.RefreshFiles();
      }
    }
    catch {/*pass for now. To Do: implement this!*/}
  }
}